import numpy as np


def dnorm(x, mean, std):
    return 0.5 * (1 + erf((x - mean) / np.sqrt(2 * std * std)))


def erf(x):
    cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2, -9.561514786808631e-3,
           -9.46595344482036e-4, 3.66839497852761e-4,
           4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6,
           1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8,
           6.529054439e-9, 5.059343495e-9, -9.91364156e-10, -2.27365122e-10, 9.6467911e-11, 2.394038e-12, -6.886027e-12,
           8.94487e-13, 3.13092e-13, -1.12708e-13, 3.81e-16, 7.106e-15, -1.523e-15, -9.4e-17, 1.21e-16, -2.8e-17
           ]
    j = len(cof) - 1
    is_neg = False
    d, dd = 0, 0

    if x < 0:
        x = -x
        is_neg = True

    t = 2 / (2 + x)
    ty = 4 * t - 2

    for i in range(len(cof) - 1, 0, -1):
        tmp = d
        d = ty * d - dd + cof[j]
        dd = tmp

    res = t * np.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd)
    return res - 1 if is_neg else 1 - res


__all__ = [
    'dnorm'
]
